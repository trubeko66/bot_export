"""
ZIP Archive Utilities for Telegram Channel Export Bot
Handles creation of ZIP archives containing exported data and media files
"""
import os
import zipfile
import tempfile
from typing import List, Optional
from pathlib import Path
import shutil


class ZipArchiveCreator:
    """Creates ZIP archives for exported channel data"""
    
    def __init__(self, export_folder: str):
        self.export_folder = export_folder
    
    async def create_export_archive(self, 
                                  main_file_path: str,
                                  media_files: List[str],
                                  channel_username: str,
                                  export_format: str) -> str:
        """
        Create a ZIP archive containing the main export file and media files
        
        Args:
            main_file_path: Path to the main export file (JSON/CSV/Markdown)
            media_files: List of media file paths relative to export folder
            channel_username: Channel username for naming
            export_format: Export format for naming
            
        Returns:
            Path to the created ZIP archive
        """
        
        # Create archive filename
        timestamp = Path(main_file_path).stem.split('_')[-1]  # Extract timestamp
        archive_name = f"{channel_username}_{timestamp}_{export_format}.zip"
        archive_path = os.path.join(self.export_folder, archive_name)
        
        # Create the ZIP archive
        with zipfile.ZipFile(archive_path, 'w', zipfile.ZIP_DEFLATED, compresslevel=6) as zipf:
            # Add main export file
            if os.path.exists(main_file_path):
                main_filename = os.path.basename(main_file_path)
                zipf.write(main_file_path, main_filename)
            
            # Add media files if they exist
            if media_files:
                # Create media folder in archive
                for media_file in media_files:
                    media_path = os.path.join(self.export_folder, 'media', media_file)
                    if os.path.exists(media_path):
                        # Store media files in a 'media' folder within the ZIP
                        archive_media_path = f"media/{media_file}"
                        zipf.write(media_path, archive_media_path)
            
            # Add metadata file
            await self._add_metadata_file(zipf, channel_username, export_format, 
                                        len(media_files) if media_files else 0)
        
        return archive_path
    
    async def _add_metadata_file(self, zipf: zipfile.ZipFile, 
                               channel_username: str, 
                               export_format: str, 
                               media_count: int):
        """Add a metadata file to the ZIP archive"""
        from datetime import datetime
        
        metadata_content = f"""# Export Information

Channel: @{channel_username}
Export Format: {export_format.upper()}
Export Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Media Files Included: {media_count}

## Contents:
- Main export file ({export_format} format)
{"- Media folder with downloaded files" if media_count > 0 else "- No media files included"}

## File Structure:
```
{channel_username}_{export_format}.zip
├── {channel_username}_[timestamp].{export_format}  # Main export file
{"├── media/                                    # Media files folder" if media_count > 0 else ""}
{"│   ├── photo_[id].jpg                        # Photos" if media_count > 0 else ""}
{"│   ├── video_[id].mp4                        # Videos" if media_count > 0 else ""}
{"│   └── file_[id].[ext]                       # Other files" if media_count > 0 else ""}
└── README.txt                              # This file
```

Generated by Telegram Channel Export Bot
"""
        
        # Write metadata to temporary file and add to ZIP
        with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False, encoding='utf-8') as tmp:
            tmp.write(metadata_content)
            tmp.flush()
            zipf.write(tmp.name, 'README.txt')
        
        # Clean up temporary file
        os.unlink(tmp.name)
    
    def cleanup_files(self, files_to_remove: List[str]):
        """Clean up temporary files after archive creation"""
        for file_path in files_to_remove:
            try:
                if os.path.exists(file_path):
                    if os.path.isfile(file_path):
                        os.remove(file_path)
                    elif os.path.isdir(file_path):
                        shutil.rmtree(file_path)
            except Exception as e:
                print(f"Warning: Could not remove {file_path}: {e}")
    
    def get_archive_size_mb(self, archive_path: str) -> float:
        """Get archive size in MB"""
        if os.path.exists(archive_path):
            return os.path.getsize(archive_path) / (1024 * 1024)
        return 0.0
    
    def validate_archive(self, archive_path: str) -> bool:
        """Validate that the ZIP archive is not corrupted"""
        try:
            with zipfile.ZipFile(archive_path, 'r') as zipf:
                bad_file = zipf.testzip()
                return bad_file is None
        except Exception:
            return False